#include <avr/io.h>
#include <avr/interrupt.h>
#include "inits.h"
#include "usart.h"

uint16_t sine[256] =
{
	0x800,0x832,0x864,0x896,0x8c8,0x8fa,0x92c,0x95e,
	0x98f,0x9c0,0x9f1,0xa22,0xa52,0xa82,0xab1,0xae0,
	0xb0f,0xb3d,0xb6b,0xb98,0xbc5,0xbf1,0xc1c,0xc47,
	0xc71,0xc9a,0xcc3,0xceb,0xd12,0xd39,0xd5f,0xd83,
	0xda7,0xdca,0xded,0xe0e,0xe2e,0xe4e,0xe6c,0xe8a,
	0xea6,0xec1,0xedc,0xef5,0xf0d,0xf24,0xf3a,0xf4f,
	0xf63,0xf76,0xf87,0xf98,0xfa7,0xfb5,0xfc2,0xfcd,
	0xfd8,0xfe1,0xfe9,0xff0,0xff5,0xff9,0xffd,0xffe,
	0xfff,0xffe,0xffd,0xff9,0xff5,0xff0,0xfe9,0xfe1,
	0xfd8,0xfcd,0xfc2,0xfb5,0xfa7,0xf98,0xf87,0xf76,
	0xf63,0xf4f,0xf3a,0xf24,0xf0d,0xef5,0xedc,0xec1,
	0xea6,0xe8a,0xe6c,0xe4e,0xe2e,0xe0e,0xded,0xdca,
	0xda7,0xd83,0xd5f,0xd39,0xd12,0xceb,0xcc3,0xc9a,
	0xc71,0xc47,0xc1c,0xbf1,0xbc5,0xb98,0xb6b,0xb3d,
	0xb0f,0xae0,0xab1,0xa82,0xa52,0xa22,0x9f1,0x9c0,
	0x98f,0x95e,0x92c,0x8fa,0x8c8,0x896,0x864,0x832,
	0x800,0x7cd,0x79b,0x769,0x737,0x705,0x6d3,0x6a1,
	0x670,0x63f,0x60e,0x5dd,0x5ad,0x57d,0x54e,0x51f,
	0x4f0,0x4c2,0x494,0x467,0x43a,0x40e,0x3e3,0x3b8,
	0x38e,0x365,0x33c,0x314,0x2ed,0x2c6,0x2a0,0x27c,
	0x258,0x235,0x212,0x1f1,0x1d1,0x1b1,0x193,0x175,
	0x159,0x13e,0x123,0x10a,0xf2,0xdb,0xc5,0xb0,
	0x9c,0x89,0x78,0x67,0x58,0x4a,0x3d,0x32,
	0x27,0x1e,0x16,0xf,0xa,0x6,0x2,0x1,
	0x0,0x1,0x2,0x6,0xa,0xf,0x16,0x1e,
	0x27,0x32,0x3d,0x4a,0x58,0x67,0x78,0x89,
	0x9c,0xb0,0xc5,0xdb,0xf2,0x10a,0x123,0x13e,
	0x159,0x175,0x193,0x1b1,0x1d1,0x1f1,0x212,0x235,
	0x258,0x27c,0x2a0,0x2c6,0x2ed,0x314,0x33c,0x365,
	0x38e,0x3b8,0x3e3,0x40e,0x43a,0x467,0x494,0x4c2,
	0x4f0,0x51f,0x54e,0x57d,0x5ad,0x5dd,0x60e,0x63f,
	0x670,0x6a1,0x6d3,0x705,0x737,0x769,0x79b,0x7cd
};

uint16_t expDecay[256] =
{
	0x0,0x3f,0x7e,0xbc,0xf8,0x134,0x16e,0x1a8,
	0x1e1,0x219,0x250,0x287,0x2bc,0x2f1,0x325,0x358,
	0x38a,0x3bb,0x3ec,0x41c,0x44b,0x479,0x4a7,0x4d4,
	0x501,0x52c,0x557,0x581,0x5ab,0x5d4,0x5fc,0x624,
	0x64b,0x672,0x698,0x6bd,0x6e2,0x706,0x72a,0x74d,
	0x76f,0x791,0x7b3,0x7d3,0x7f4,0x814,0x833,0x852,
	0x871,0x88f,0x8ac,0x8c9,0x8e6,0x902,0x91e,0x939,
	0x954,0x96e,0x988,0x9a2,0x9bb,0x9d4,0x9ed,0xa05,
	0xa1d,0xa34,0xa4b,0xa62,0xa78,0xa8e,0xaa3,0xab9,
	0xace,0xae2,0xaf6,0xb0a,0xb1e,0xb31,0xb45,0xb57,
	0xb6a,0xb7c,0xb8e,0xb9f,0xbb1,0xbc2,0xbd3,0xbe3,
	0xbf4,0xc04,0xc13,0xc23,0xc32,0xc41,0xc50,0xc5f,
	0xc6d,0xc7b,0xc89,0xc97,0xca5,0xcb2,0xcbf,0xccc,
	0xcd9,0xce5,0xcf1,0xcfe,0xd0a,0xd15,0xd21,0xd2c,
	0xd37,0xd42,0xd4d,0xd58,0xd63,0xd6d,0xd77,0xd81,
	0xd8b,0xd95,0xd9e,0xda8,0xdb1,0xdba,0xdc3,0xdcc,
	0xdd5,0xddd,0xde6,0xdee,0xdf6,0xdfe,0xe06,0xe0e,
	0xe16,0xe1e,0xe25,0xe2c,0xe34,0xe3b,0xe42,0xe49,
	0xe4f,0xe56,0xe5d,0xe63,0xe6a,0xe70,0xe76,0xe7c,
	0xe82,0xe88,0xe8e,0xe94,0xe99,0xe9f,0xea4,0xeaa,
	0xeaf,0xeb4,0xeb9,0xebe,0xec3,0xec8,0xecd,0xed2,
	0xed6,0xedb,0xedf,0xee4,0xee8,0xeed,0xef1,0xef5,
	0xef9,0xefd,0xf01,0xf05,0xf09,0xf0d,0xf11,0xf14,
	0xf18,0xf1c,0xf1f,0xf23,0xf26,0xf29,0xf2d,0xf30,
	0xf33,0xf36,0xf39,0xf3c,0xf3f,0xf42,0xf45,0xf48,
	0xf4b,0xf4e,0xf51,0xf53,0xf56,0xf59,0xf5b,0xf5e,
	0xf60,0xf63,0xf65,0xf67,0xf6a,0xf6c,0xf6e,0xf71,
	0xf73,0xf75,0xf77,0xf79,0xf7b,0xf7d,0xf7f,0xf81,
	0xf83,0xf85,0xf87,0xf89,0xf8b,0xf8d,0xf8e,0xf90,
	0xf92,0xf94,0xf95,0xf97,0xf98,0xf9a,0xf9c,0xf9d,
	0xf9f,0xfa0,0xfa2,0xfa3,0xfa5,0xfa6,0xfa7,0xfa9,
	0xfaa,0xfab,0xfad,0xfae,0xfaf,0xfb0,0xfb2,0xfb3
};

void dac_init()
{
	//sets DACA as output
	PORTA.DIRSET = 1<<3;
	//use only channel0
	DACA.CTRLB = DAC_CHSEL_SINGLE1_gc | DAC_CH1TRIG_bm;		
	//single1 is channel1 single is channel0
	//use AREFB (2.5V) data is right adjusted
	DACA.CTRLC = DAC_REFSEL_AREFB_gc;
			
			//this was my issue, should have not been set
			DACA.EVCTRL = 0;//DAC_EVSEL_1_gc;
	
	//enable channel 0 aswell as overall dac module
	DACA.CTRLA = DAC_CH1EN_bm | DAC_ENABLE_bm;
}

void hold(char pressed)
{
	while(usartd0_in_char() == pressed);
	TCC0.CTRLA = 0;
}

void tcc0_init(uint16_t note)
{
	/*
	E	1046.50 = 119
	4	1108.73 = 113
	R	1174.66 = 106
	5	1244.51 = 100
	T	1318.51 = 95
	Y	1396.91 = 89
	7	1479.98 = 84
	U	1567.98 = 80
	8	1661.22 = 75
	I	1760.00 = 71
	9	1864.66 = 67
	O	1975.53 = 63
	P	2093.00 = 60
	*/
	
	//PMIC.CTRL = 0x01;
	//sei();
	//TCC0.INTCTRLA = TC0_OVFINTLVL0_bm;
	EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc;
	//80 per with div2 is 783.7 approx
	//161 per with div1 is 783.6 approx
	TCC0.PER = note;
	TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
	
	//clk freq/ pre * time i want
	//(32MHZ/1 * (1/784))/256		256 is how many data points
	//add 50 to 784 for part 2.3
	//+- 2% expected value * 2% +
}

void tcc1_init(void)
{
	TCC1.PER = 20000;
	//TCC1.CTRLA = TC_CLKSEL_DIV2_gc;
	TCC1.INTCTRLA = TC_OVFINTLVL_LO_gc;
	PMIC.CTRL = 0x01;
}

void dma_init(void)
{
	//reset entire dma perif
	DMA.CTRL |= DMA_RESET_bm;
	
	DMA.CH0.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_2BYTE_gc;
	
	DMA.CH0.ADDRCTRL = DMA_CH_SRCRELOAD_BLOCK_gc | DMA_CH_SRCDIR_INC_gc | 
						DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;
	
	DMA.CH0.TRIGSRC = DMA_CH_TRIGSRC_EVSYS_CH0_gc;
	
	DMA.CH0.TRFCNT = (uint16_t)(sizeof(sine));
	
	DMA.CH0.SRCADDR0 = (uint8_t)((uintptr_t)sine);
	DMA.CH0.SRCADDR1 = (uint8_t)(((uintptr_t)sine)>>8);
	DMA.CH0.SRCADDR2 = (uint8_t)(((uint32_t)((uintptr_t)sine))>>16);
	
	DMA.CH0.DESTADDR0 = (uint8_t)((uintptr_t)&DACA.CH1DATA);
	DMA.CH0.DESTADDR1 = (uint8_t)(((uintptr_t)&DACA.CH1DATA)>>8);
	DMA.CH0.DESTADDR2 = (uint8_t)(((uint32_t)((uintptr_t)&DACA.CH1DATA))>>16);
	
	//enable channel 0
	DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
	
	//EVSYS.CH0MUX = EVSYS_CHMUX_TCC0_OVF_gc;
	
	//enable entire dma
	DMA.CTRL |= DMA_ENABLE_bm;
	
}

void dma_init_expDecay(void)
{
		//reset entire dma perif
		DMA.CTRL |= DMA_RESET_bm;
		
		DMA.CH0.CTRLA = DMA_CH_SINGLE_bm | DMA_CH_BURSTLEN_2BYTE_gc;
		
		DMA.CH0.ADDRCTRL = DMA_CH_SRCRELOAD_BLOCK_gc | DMA_CH_SRCDIR_INC_gc |
		DMA_CH_DESTRELOAD_BURST_gc | DMA_CH_DESTDIR_INC_gc;
		
		DMA.CH0.TRIGSRC = DMA_CH_TRIGSRC_EVSYS_CH0_gc;
		
		DMA.CH0.TRFCNT = (uint16_t)(sizeof(expDecay));
		
		DMA.CH0.SRCADDR0 = (uint8_t)((uintptr_t)expDecay);
		DMA.CH0.SRCADDR1 = (uint8_t)(((uintptr_t)expDecay)>>8);
		DMA.CH0.SRCADDR2 = (uint8_t)(((uint32_t)((uintptr_t)expDecay))>>16);
		
		DMA.CH0.DESTADDR0 = (uint8_t)((uintptr_t)&DACA.CH1DATA);
		DMA.CH0.DESTADDR1 = (uint8_t)(((uintptr_t)&DACA.CH1DATA)>>8);
		DMA.CH0.DESTADDR2 = (uint8_t)(((uint32_t)((uintptr_t)&DACA.CH1DATA))>>16);
		
		//enable channel 0
		DMA.CH0.CTRLA |= DMA_CH_ENABLE_bm;
		
		//enable entire dma
		DMA.CTRL |= DMA_ENABLE_bm;
}